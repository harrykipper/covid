to export-network
  file-open "lizzanello_net.csv"
  ask households [
    ask both-ends [;
      file-type (word who ",")
    ]
    file-print (word ltype ",household" )
  ]
  ask friendships [
    ask both-ends [file-type (word who ",")]
    file-print (word mean-age ",friendship")
  ] 
  ask relations [
    ask both-ends [file-type (word who ",")]
    file-print ",relation"
  ]
  file-close
end

to import-network
  ask turtles [
    set friends []
    set relatives []
    set hh []
  ]
  
  foreach csv:from-file "lizzanello_net.csv" [lnk ->
    let orig item 0 lnk
    let dest item 1 lnk
    let attr item 2 lnk
    ifelse item 3 lnk = "friendship" [
      ask turtle orig [set friends lput (turtle dest) friends]
      ask turtle dest [set friends lput (turtle orig) friends]
    ]
    [ifelse item 3 lnk = "relation" 
      [
        ask turtle orig [set relatives lput turtle dest relatives]
        ask turtle dest [set relatives lput turtle orig relatives]
      ]
      [
        ask turtle orig [set hh lput turtle dest hh]
        ask turtle dest [set hh lput turtle orig hh]
      ]
    ]
  ]
  
  ask turtles [
    set friends turtle-set friends
    set relatives turtle-set relatives
    set hh turtle-set hh
  ]
end


;; ==========================================================
;;                     SOCIAL NETWORK GENERATION
;; ==========================================================

to create-hh
 ; create-marriages
  if show-layout [repeat 50 [layout]]
 ; attach-children
  ;repeat count turtles with [status = 0] / 2 [layout]
  if show-layout [repeat 50 [layout]]
end

;to create-schools
;  foreach [6 7 8 9 10 11 12 13 14 15 16 17][a ->
;    let thesekids turtles with [age = a]
;    ifelse count thesekids > 30 [
;      let howManyClasses ceiling (count thesekids / 30)
;      let kidsperclass (count thesekids / howManyClasses)
;      let c 1
;      while [c <= howManyClasses] [
;        let thisclass up-to-n-of kidsperclass thesekids with [count my-classes = 0]
;        ask thisclass [create-classes-with other thisclass [set name (word a "-" c)]]
;        set c c + 1
;      ]
;    ]
;    [ask turtles with [age = a and count my-classes = 0] [create-classes-with other turtles with [age = a and count my-classes = 0][set name (word a "-" 0)]]]
;  ]
;end

to create-schools
  set school table:make
  foreach [6 7 8 9 10 11 12 13 14 15 16 17][a ->
    let thesekids turtles with [age = a]
    ask thesekids [set myclass 0]
    ifelse count thesekids > 30 [
      let howManyClasses ceiling (count thesekids / 30)
      let kidsperclass (count thesekids / howManyClasses)
      let c 1
      while [c <= howManyClasses] [
        let thisclass up-to-n-of kidsperclass thesekids with [myclass = 0]
        ask thisclass [set myclass (word a "-" c)]
        table:put school (word a "-" c) thisclass
        set c c + 1
      ]
    ]
    [
      let orphans turtles with [age = a and myclass = 0]
      ask orphans [set myclass (word a "-" 0)]
      table:put school (word a "-" 0) orphans
    ]
  ]
end

;; make the initial network of initial-links-per-age-group edges per age group
to make-initial-links
  foreach (list [6 10][11 14][15 19][20 25][26 36][37 49][50 65][66 80][81 103]) [a-g ->
    repeat initial-links-per-age-group [
      let theseguys turtles with [age >= item 0 a-g and age <= item 1 a-g]
      ask one-of theseguys [
        create-friendship-with one-of other theseguys [
          if show-layout [set color green]
          set mean-age mean [age] of both-ends
        ]
      ]
    ]
  ]
end

;; This code is the heart of the "preferential attachment" mechanism. 
;; We exploit the asyncronous nature of NetLogo and link agents to other agents who already have links
;; We skew the mechanism a bit to allow for friendships being built 
;; within age classes as much as possible.

to-report find-partner
  let partner nobody
  let connection nobody
  
  
end

