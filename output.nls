;; ============================================
;;                 OUTPUT
;; ============================================

to calculate-r0
  let new-infected nb-infected
  let new-recovered nb-recovered
  let currently-infected table:get populations "infected"
  let currently-recovered table:get populations "recovered"
  set nb-infected-previous (currently-infected + new-recovered - new-infected)  ;; Number of infected people at the previous tick
  let susceptible-t (N-people - currently-infected - currently-recovered)  ;; Number of susceptibles now
  ifelse nb-infected-previous < 10
  [ set beta-n 0 ]
  [ set beta-n (new-infected / nb-infected-previous) ]       ;; This is the average number of new secondary infections per infected this tick
  
  ifelse nb-infected-previous < 5
  [ set gamma 0 ]
  [ set gamma (new-recovered / nb-infected-previous) ]    ;; This is the average number of new recoveries per infected this tick
  
  if ((N-people - susceptible-t) != 0 and (susceptible-t != 0))   ;; Prevent from dividing by 0
  [
    ;; This is derived from integrating dI / dS = (beta*SI - gamma*I) / (-beta*SI)
    ;; Assuming one infected individual introduced in the beginning, and hence counting I(0) as negligible,
    ;; we get the relation
    ;; N - gamma*ln(S(0)) / beta = S(t) - gamma*ln(S(t)) / beta, where N is the initial 'susceptible' population.
    ;; Since N >> 1
    ;; Using this, we have R_0 = beta*N / gamma = N*ln(S(0)/S(t)) / (K-S(t))
    set r0 (ln (s0 / susceptible-t) / (N-people - susceptible-t))
    set r0 r0 * s0 
  ]
end

to current-rt
  let fresh turtles with [cured-since >= (ticks - 7)]
  set rtime ifelse-value count fresh > 0 
  [mean ([spreading-to] of fresh)]
  [0]
end

;; =================== SUMMARY ==================

to print-current-summary
  let infected count turtles with [infected?]
  let recovered count turtles with [cured?]
  let propinf precision (infected / N-people) 3
  let proprec precision (recovered / N-people) 3
  let proprec2 precision (recovered / (infected + count turtles with [cured?])) 3
  output-print (word "Currently infected: " infected " (" (propinf * 100) "% of population)" )
  output-print (word "Currently recovered: " recovered " (" (proprec * 100) "% of population - " (proprec2 * 100) "% of all infected)" )
  output-print (word "Current average R0: " precision r0 2)
end

to print-final-summary
  let totalinf count turtles with [ cured? ] + count turtles with [ infected? ]
  let totalinfpct precision ((totalinf / N-people) * 100) 3
  let deaths count turtles with [dead?]
  output-print " ================================ "
  output-print (word "End of epidemic: day " ticks)
  output-print (word "Total infected: " totalinfpct "% of population" )
  output-print (word "Total deaths: " deaths ". " count turtles with [dead? and sex = "M"] " men, " count turtles with [dead? and sex = "F"] " women. Median age: " median [age] of turtles with [dead?]" - Mortality rate: " precision ((deaths / totalinf) * 100) 2 "%")
  output-print (word "Tests performed: " tests-performed)
  ;output-print (word "R0: " precision r0 2)
  let tot sum table:values counters
  output-print "Infections from household, relations, friends, school, random: "
  foreach table:values counters [c -> 
    output-type (word (precision (c / tot) 2) " ")]
end

to save-output
  let deaths table:get populations "dead"
  let totalinf table:get populations "infected" + table:get populations "recovered"
  let recovered table:get populations "recovered"
  ifelse file-exists? "covid19.csv"
  [file-open "covid19.csv"]
  [
    file-open "covid19.csv"
    file-print "run,pctApp,pctTest,lockdown,schools,compliance,deaths,propInfected,R0,mortality,days,tests,household,relations,friends,school,random"
  ]
  let tot sum table:values counters
  file-type (
    word behaviorspace-run-number "," pct-with-tracing-app "," tests-per-100-people "," lockdown-at-first-death "," schools-open? "," app-compliance "," deaths
    "," ((totalinf / N-people) * 100)
    "," r0 "," (precision ((deaths / totalinf) * 100) 2) "," ticks "," tests-performed)
  ifelse tot > 0 
  [foreach table:values counters [c -> file-type (word "," (precision (c / tot) 2))]]
  [file-type ",0,0,0,0,0"]
  file-print ""
  file-close
end

to save-individual 
  ifelse file-exists? "covid19_ind.csv" 
  [file-open "covid19_ind.csv"]
  [
    file-open "covid19_ind.csv"
    file-print "run,t,pctApp,pctTest,lockdown,schoolsopen,compliance,susceptible,infected,recovered,isolated,dead,hospitalized,tests"
  ]
  file-print ( word behaviorspace-run-number "," ticks "," pct-with-tracing-app "," tests-per-100-people ","
    lockdown-at-first-death ","  schools-open? "," app-compliance "," csv:to-row table:values populations  "," in-hospital "," tests-performed ) 
  file-close
end

to plot-friends
  set-current-plot "Degree distribution (log-log)"
  let max-degree max [count friends] of turtles with [age > 12]
  ;; for this plot, the axes are logarithmic, so we can't
  ;; use "histogram-from"; we have to plot the points
  ;; ourselves one at a time
  plot-pen-reset  ;; erase what we plotted before
                  ;; the way we create the network there is never a zero degree node,
                  ;; so start plotting at degree one
  let degree 1
  while [degree <= max-degree] [
    let matches turtles with [age > 12 and count friends = degree]
    if any? matches
    [ plotxy log degree 10
      log (count matches) 10 ]
    set degree degree + 1
  ]
  
  
  set-current-plot "Degree distribution"
  set max-degree max [count friends] of turtles with [age > 12]
  plot-pen-reset  ;; erase what we plotted before
  set-plot-x-range 1 (max-degree + 1)  ;; + 1 to make room for the width of the last bar
  histogram [count friends] of turtles with [age > 12]
end